---
title: "1.2: Why Write Code in Grasshopper?"
aliases:
  - I discuss the limitations of "vanilla" Grasshopper, and offer a few reasons why custom code could be benefitial for you.
---
### Why Coding?
Grasshopper에서 프로그래밍 언어를 통해 개발을 하는 이유에 대해 이야기해봅시다. 왜 우리가 코드를 작성하고 자체 플러그인을 만드는 등의 일을 해야 할까? Grasshopper로 이미 충분하고, 사용하기 쉽고, 입문하기 좋은데 왜 이렇게 복잡하게 만들어야 할까요?

첫 번째로 말씀드릴 것은 '힘'과 '자유'를 얻기 위해서입니다. 커스터마이징은 항상 이 두 가지를 가져다줍니다. 하지만 이건 너무 추상적인 이야기이니, 구체적으로 살펴보겠습니다.

### Grasshopper의 기본 특성과 장점
- 비주얼 프로그래밍 모델
- 컴포넌트 기반 인터페이스
- 초보자 친화적 추상화

Grasshopper가 이렇게 성공적인 이유는 *비주얼 프로그래밍* 이라는 모델을 제공하기 때문입니다. 여기서 우리가 하고 싶은 모든 기하학적 작업은 '컴포넌트'라는 박스로 표현됩니다. 이 메타포가 사용자에게 제공하는 것은, 사용자는 입력값이 무엇인지, 즉 컴포넌트가 작동하는데 필요한 데이터가 무엇인지만 신경 쓰면 되고, 우리는 작업 결과를 출력으로 제공할 것입니다. 내부에서 일어나는 일들은 사용자로부터 추상화되어 있어서, 사용자는 신경 쓸 필요가 없습니다.

사용자는 이러한 컴포넌트들을 배치하고 와이어로 올바르게 연결하여 기하학적 관계의 트리를 만드는 것에만 집중하면 됩니다. 이는 초보자들과 학습자들에게 아주 좋은 메타포입니다. 기하학적 의미를 배우는 것만으로도 충분히 해야 할 일이 많은데, 컴퓨터 코드 작성법까지 배워야 하는 부담이 없기 때문입니다.

### Grasshopper의 한계
- 성능 제약
- 컴포넌트 오버헤드
- 블랙박스 모델의 한계

하지만 Grasshopper에 이미 능숙하고 작동 방식을 잘 알며 놀라운 정의들을 만들 수 있는 사용자들의 경우, 기본 Grasshopper의 한계에 쉽게 부딪힐 수 있습니다. 이러한 한계 중 하나는 성능입니다. Grasshopper의 성능은 꽤 좋은 편이지만 최고는 아닙니다. 각각의 컴포넌트는 그 자체로 작은 프로그램이며, 입력을 출력으로 변환하는 코드뿐만 아니라 많은 오버헤드 코드가 있습니다. 입력을 받고, 출력을 내보내고, Grasshopper 타입과 Rhino 타입 간의 변환을 처리하고, 특정 아이콘으로 화면에 표시되는 등의 작업이 필요합니다.

이러한 컴포넌트의 모듈성으로 인해 많은 **오버헤드**가 발생합니다. 데이터를 교환하는 여러 개의 컴포넌트 대신, 모든 작업을 수행하는 하나의 큰 컴포넌트를 사용한다면 성능이 훨씬 더 좋아질 수 있습니다.

또한 Grasshopper 전문가 수준에 도달했다면, surface subdivision 컴포넌트 내부에서 어떤 일이 일어나는지 알고 싶어질 수 있습니다. UV 포인트의 균일한 그리드로 표면을 분할하는 작업이 어떻게 이루어지는지 궁금해질 수 있죠. 이미 전문가 수준에 도달했기 때문입니다.

이런 측면에서 Grasshopper는 코드를 다루지 않아도 되는 블랙박스 모델을 제공하기 때문에 초보자에게는 좋지만, 전문가가 되어 이러한 질문들을 하게 될 때는 **한계**가 있습니다. 저도 항상 이런 질문들을 하게 됩니다. 컴포넌트만 사용해서는 더 깊이 배우기 어렵고, 직접 코드를 작성하거나 다른 소스를 찾아야 합니다.

### 복잡성 관리의 어려움
- Grasshopper 스파게티 현상
- 대규모 정의의 가독성 문제
- 선형적 논리 유지의 어려움
- 제한된 커스텀 기능

또한 Grasshopper에서 큰 정의들은 매우 혼란스러울 수 있습니다. **'Grasshopper 스파게티'** 라는 용어를 들어보셨을 것입니다. 지금 예시를 보여드릴 순 없지만, 큰 Grasshopper 정의를 작성하면 와이어들이 서로 얽혀있는 모습을 보게 됩니다. 매우 복잡해질 수 있어서, 그룹화하고 색상을 지정하고 이름을 붙이는 등의 작업이 필요합니다.

많은 저자들과 전문가들은 큰 규모의 컴퓨터 프로그램이 큰 Grasshopper 정의보다 읽기 쉽다고 생각합니다. 컴퓨터 프로그램은 보통 한 줄씩 순차적으로 읽을 수 있기 때문입니다. 완전히 사실은 아니지만, 순차적으로 읽을 수 있어서 인간의 마음이 이해하기 더 쉽습니다. 반면 Grasshopper에서는 너무 많은 분기가 있고 상호 연결되어 있어서 작업의 **선형적 논리**를 유지하기가 어렵습니다.

마지막으로, 커스터마이징의 한계가 있습니다. 기본 Grasshopper에서는 커스텀 프리뷰나 화면 자동 베이킹 같은 세밀한 커스터마이징이 제한됩니다. 이러한 숨겨진 기능에 접근하지 않으면 할 수 없는 일들이 많습니다.

### 개발의 이점
- 고급 기능 접근의 필요성
- 플러그인 개발의 이점
- 효율적인 코드 공유 방법
- 커뮤니티 기여 방식
- 연구와 개발의 표준

이런 면에서 Grasshopper 내에서 스크립팅을 사용하고 자체 컴포넌트를 작성함으로써, 우리는 이러한 모든 기능에 접근할 수 있고 Grasshopper 내에서 훨씬 높은 수준의 전문성을 달성할 수 있습니다.

또한, 어떤 프로세스나 새로운 기능, 훌륭한 기하학적 알고리즘을 공유하고 싶을 때, Grasshopper 정의로 공유하는 것은 보통 좋지 않습니다. Grasshopper에는 클러스터링 도구가 있어서 여러 요소를 하나의 컴포넌트로 만들고 비밀번호로 보호할 수도 있지만, 자체 컴포넌트를 작성하고 컴파일하여 플러그인으로 제공하는 것이 훨씬 더 우아하고 깔끔하며 성능이 좋은 솔루션입니다. 이것이 사람들이 Grasshopper 생태계에 기여하는 표준적인 방법이며, 연구를 하고 논문을 쓰는 방식입니다.

### 본 시리즈의 커리큐럼
- 컴포넌트 내부 이해
- 스크립팅에서 플러그인 개발로
- 전문가 수준으로의 발전

이 시리즈에서는 이러한 컴포넌트들의 내부를 더 깊이 살펴보고, 많은 인기 있는 컴포넌트들을 재현해볼 것입니다. 예를 들어, 포인트를 만드는 방법이나 표면을 분할하는 방법 등을 배우게 될 것입니다. 학습 도구로서 매우 유용한 이 컴포넌트들을 복제해볼 것입니다.

컴포넌트 내부에 숨겨진 것들, 작성된 코드, 자체 컴포넌트를 작성하는 방법 등을 더 깊이 파고들어서, 고급 Grasshopper 사용자 수준을 넘어 진정한 전문가가 될 수 있습니다.

먼저 Grasshopper 내에서 스크립팅을 사용하는 방법을 배우면서 시작할 것입니다. Grasshopper 자체 내에서 컴포넌트를 작성하는 방법을 가르쳐드리고, 이에 대한 이해가 잘 되면 Grasshopper 외부로 나가서 Visual Studio라는 개발 환경에서 Grasshopper 컴포넌트를 만들고, 이를 네이티브 Grasshopper 플러그인으로 컴파일하는 방법을 배우게 됩니다.